// Group 42:
// R Vijay Krishna 2017A7PS0183P
// Rohit K 2017A7PS0177P

#include "common.h"
#include "hash_table.h"
#include "lexer.h"
#include "parser.h"
#include "ast.h"
#include "symbol_table.h"
#include "function_table.h"
#include "time.h"

extern HashTable* keyword_table;
extern unsigned long (*hash_fun)(char*); // Function Pointer to the Hash Function
extern Keyword keywords[];
extern int num_nodes_AST;
extern int total_memory_AST;
extern int num_nodes_parse_tree;
extern int total_memory_parse_tree;
extern int total_scope;
extern int* start_num_scope;
extern int* end_num_scope;
extern bool has_semantic_error;
extern int* modules;
extern int module_index;
char** module_names;

int main(int argc, char* argv[]) {
    if (argc != 2 && argc != 3) {
        fprintf(stderr, "Format: %s <input> <output>\n", argv[0]);
        exit(EXIT_FAILURE);
    }
    
    FILE* fp = fopen("grammar_rules.txt", "r");
    Grammar g = populate_grammar(fp);
    fclose(fp);
    
    FirstAndFollow f = ComputeFirstAndFollowSets(g);
    ParseTable p = createParseTable(f, g);
    hash_fun = &hash_func;
    keyword_table = populate_hash_table(keyword_table, keywords, hash_fun);
    
    while(1) {
        printf("\nERPLAG COMPILER MENU OPTIONS:\n");
        printf("0: To exit.\n");
        printf("1: For printing the token list generated by the lexer.\n");
        printf("2: For parsing to verify the syntactic correctness of the input source code and printing the Parse Tree in an Inorder Traversal\n");
        printf("3: For generating the Abstract Syntax Tree (AST) on the console, in an Inorder Traversal\n");
        printf("4: For displaying the amount of memory and number of nodes to each of the parse tree and abstract syntax tree\n");
        printf("5: For printing the Symbol Table on the console, with appropriate parameters\n");
        printf("6: For printing the total memory requirement for each function\n");

        int option;
        scanf("%d",&option);
        
        if (option == 0)
            break;
        else if(option == 1) {
            printf("-------------------------------------------------------------\n");
            run_tokenizer(argv[1]);
            printf("-------------------------------------------------------------\n");
        }
        else if(option == 2) {
            TreeNode* parseTree = generateParseTree(argv[1], p, g);
            printf("-------------------------------------------------------------\n");
            printf("Parse Tree:\n");
            printf("Token\tLine No\tLexeme\t\tNum. Value\t\tParent\t\tIs Leaf\t\tSymbol Type\n");
            printParseTree(parseTree);
            printf("-------------------------------------------------------------\n");
            free_parse_tree(parseTree);
            total_memory_AST = 0;
            total_memory_parse_tree = 0;
            num_nodes_AST = 0;
            num_nodes_parse_tree = 0;
        }
        else if (option == 3) {
            TreeNode* parseTree = generateParseTree(argv[1], p, g);
            generate_AST(parseTree);
            printf("AST:\n");
            printf("Token\tLine No\tLexeme\t\tNum. Value\t\tParent\t\tIs Leaf\t\tSymbol Type\tSynthesized Attribute\n");
            printAbstractSyntaxTree(parseTree->node);
            free_AST(parseTree->node);
            free_parse_tree(parseTree);
            total_memory_AST = 0;
            total_memory_parse_tree = 0;
            num_nodes_AST = 0;
            num_nodes_parse_tree = 0;
        } 
        else if (option == 4) {
            TreeNode* parseTree = generateParseTree(argv[1], p, g);
            generate_AST(parseTree);
            printf("Parse Tree: Number of Nodes = %d\t\tAllocated Memory = %lu bytes (%.4f MB)\n", num_nodes_parse_tree, total_memory_parse_tree, (double) total_memory_parse_tree / 1024);
            printf("AST: Number of Nodes = %d\t\tAllocated Memory = %lu bytes (%.4f MB)\n", num_nodes_AST, total_memory_AST, (double) total_memory_AST / 1024);
            double compression_percent = 100 * (((float) total_memory_parse_tree - total_memory_AST) / (float) (total_memory_parse_tree));
            printf("Compression Percentage = %.4f\n", compression_percent);
            free_AST(parseTree->node);
            free_parse_tree(parseTree);
            total_memory_AST = 0;
            total_memory_parse_tree = 0;
            num_nodes_AST = 0;
            num_nodes_parse_tree = 0;
        }
        else if (option == 5) {
            TreeNode* parseTree = generateParseTree(argv[1], p, g);
            generate_AST(parseTree);

            // Symbol Tables
            SymbolHashTable*** tables_ptr = createSymbolTables(parseTree->node);
            SymbolHashTable** tables = *tables_ptr;
            
            // Print the Symbol Tables
            print_symtables(tables, total_scope);

            // Reset semantic error flag
            has_semantic_error = false;
            
            if (start_num_scope) free(start_num_scope);
            if (end_num_scope) free(end_num_scope);
            free_stacks(30);
            free_symtables(tables, total_scope);
            free(tables_ptr);

            free_AST(parseTree->node);
            free_parse_tree(parseTree);
            total_scope = 0;
        }
        else if (option == 6) {
            // Print the Function Tables
            TreeNode* parseTree = generateParseTree(argv[1], p, g);
            generate_AST(parseTree);

            // Symbol Tables
            SymbolHashTable*** tables_ptr = createSymbolTables(parseTree->node);
            SymbolHashTable** tables = *tables_ptr;
            
            // print_function_tables(total_scope + 1);

            // Reset semantic error flag
            has_semantic_error = false;
            
            if (start_num_scope) free(start_num_scope);
            if (end_num_scope) free(end_num_scope);
            free_stacks(30);
            free_symtables(tables, total_scope);
            free(tables_ptr);

            free_AST(parseTree->node);
            free_parse_tree(parseTree);
        }
        else if (option == 7) {

        }
        else if (option == 8) {
            clock_t start_time, end_time;
            double total_CPU_time_lexer, total_CPU_time_parser, total_CPU_time_in_seconds_lexer, total_CPU_time_in_seconds_parser;

            start_time = clock();
            run_tokenizer(argv[1]);
            end_time = clock();
            total_CPU_time_lexer  =  (double) (end_time - start_time);
            total_CPU_time_in_seconds_lexer =   total_CPU_time_lexer / CLOCKS_PER_SEC;

            start_time = clock();
            TreeNode* parseTree = generateParseTree(argv[1], p, g);
            end_time = clock();
            total_CPU_time_parser  =  (double) (end_time - start_time);
            total_CPU_time_in_seconds_parser =   total_CPU_time_parser / CLOCKS_PER_SEC;
            
            printf("--------------------------------------------------------------\n");
            printf("Total CPU Time taken for the Lexer: %.6f\n", total_CPU_time_lexer);
            printf("Total CPU Time in seconds taken for the Lexer: %.6f seconds\n", total_CPU_time_in_seconds_lexer);
                    
            printf("Time CPU Time taken for the Parser: %.6f\n", total_CPU_time_parser);
            printf("Time CPU Time in seconds taken for the Parser: %.6f seconds\n", total_CPU_time_in_seconds_parser);
            printf("--------------------------------------------------------------\n");
            free_parse_tree(parseTree);
            total_memory_AST = 0;
            total_memory_parse_tree = 0;
            num_nodes_AST = 0;
            num_nodes_parse_tree = 0;
        }
        else {
            printf("\nInvalid Option\n");
            total_memory_AST = 0;
            total_memory_parse_tree = 0;
            num_nodes_AST = 0;
            num_nodes_parse_tree = 0;
        }
    }

    free_parse_table(p);
    free_first_and_follow(f);
    free_grammar(g);
    free_table(keyword_table);
    return 0;
}
