<program> -> <moduleDeclarations> <otherModules> <driverModule> <otherModules>
<moduleDeclarations> -> <moduleDeclaration> | E
<moduleDeclaration> -> DECLARE MODULE ID SEMICOL
<otherModules> -> <module> <otherModules> | E
<driverModule> -> DRIVERDEF DRIVER PROGRAM DRIVERENDDEF <moduleDef>
<module> -> DEF MODULE ID ENDDEF TAKES INPUT SQBO <input_plist> SQBC SEMICOL <ret> <moduleDef>
<ret> -> RETURNS SQBO <output_plist> SQBC SEMICOL | E
<input_plist> -> ID COLON <dataType> <IPL>
<IPL> -> COMMA ID COLON <dataType> <IPL> | E
<output_plist> -> ID COLON <type> <OPL>
<OPL> -> COMMA ID COLON <type> <OPL> | E 
<dataType> -> INTEGER | REAL | BOOLEAN | ARRAY SQBO <range> SQBC OF <type>
<type> -> INTEGER | REAL | BOOLEAN
<moduleDef> -> START <statements> END
<statements> -> <statement> <statements> | E
<statement> -> <ioStmt> | <simpleStmt> | <declareStmt> | <conditionalStmt> | <iterativeStmt>
<ioStmt> -> GET_VALUE BO ID BC SEMICOL | PRINT BO <var> BC SEMICOL
<var> -> ID <whichId> | NUM | RNUM | TRUE | FALSE
<whichId> -> SQBO ID SQBC | E
<simpleStmt> -> <assignmentStmt> | <moduleReuseStmt>
<assignmentStmt> -> ID <whichStmt>
<whichStmt> -> <lvalueIDStmt> | <lvalueARRStmt>
<lvalueIDStmt> -> ASSIGNOP <expression> SEMICOL
<lvalueARRStmt> -> SQBO <index> SQBC ASSIGNOP <expression> SEMICOL
<index> -> NUM | ID
<moduleReuseStmt> -> <optional> USE MODULE ID WITH PARAMETERS <idList> SEMICOL
<optional> -> SQBO <idList> SQBC ASSIGNOP | E
<idList> -> ID <IDL>
<IDL> -> COMMA ID <IDL> | E
<Unary> ->  MINUS UX | PLUS UX 
<UX> -> <var> | BO <AorBExpr> BC
<expression> -> <AorBExpr> <NX> | <Unary>
<NX> -> <logicalOp> <AorBExpr> <NX> | E
<AorBExpr> -> <arithmeticExpr> <NY>
<NY> -> <relationalOp> <arithmeticExpr> <NY> | E
<arithmeticExpr> -> <term> <ARE>
<ARE> -> <AOP> <term> <ARE> | E
<AOP> -> PLUS | MINUS
<term> -> <factor> <FAC>
<FAC> -> <MOP> <factor> <FAC> | E
<MOP> -> MUL | DIV
<factor> -> BO <expression> BC
<factor> -> <var>
<logicalOp> -> AND | OR
<relationalOp> -> LT | LE | GT | GE | EQ | NE
<declareStmt> -> DECLARE <idList> COLON <dataType> SEMICOL
<conditionalStmt> -> SWITCH BO ID BC START <caseStmts> <default> END
<caseStmts> -> CASE <value> COLON <statements> BREAK SEMICOL <cStmt>
<cStmt> -> CASE <value> COLON <statements> BREAK SEMICOL <cStmt> | E
<value> -> NUM | TRUE | FALSE
<default> -> DEFAULT COLON <statements> BREAK SEMICOL | E
<iterativeStmt> -> FOR BO ID IN <range> BC START <statements> END
<iterativeStmt> -> WHILE BO <booleanExpr> BC START <statements> END
<range> -> NUM RANGEOP NUM
